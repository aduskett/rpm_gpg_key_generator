#!/usr/bin/env bash
set -eu
set -o pipefail

CWD=$(pwd)
BASENAME="$(basename $(pwd))"
TMP_DIR="${CWD}"/tmp
OUTPUT_DIR="${CWD}"/output
GPG_HOME_DIR="${OUTPUT_DIR}"/gpg_home
GPG_BATCH_FILE=""
NAME="testuser"
EMAIL="testuser@email.com"
EXPIRE_DATE="0"
PASSPHRASE="test123"

print_help()
{
    echo "usage: make_gpg_keys [-h] -b -c -d -e -n -o -p -x"
    echo ""
    echo "options:"
    echo "-h, --help              Show this help message and exit."
    echo "-b, --gpg-batch-file    GPG batch file location. If unspecified, one will be generated automatically."
    echo "-d, --gpg-home-dir      GPG home directory location. Must not be ${HOME}/.gnupg"
    echo "-e, --email             GPG key email address/"
    echo "-n, --name              Name used for the GPG key."
    echo "-o, --output            Output directory for the armored GPG key, key secret, and key passphrase."
    echo "-p, --passphrase        GPG key passphrase."
    echo "-x, --expire-date       GPG key expiration date."
    echo ""
    exit 0
}

parse_args() {
  local o O opts
  o='hb:d:e:n:o:p:x:'
  O='help,gpg-batch-file:,email:,gpg-home-dir:,name:,output:,passphrase:,expire-date:'
  opts="$(getopt -o "${o}" -l "${O}" -- "${@}")"
  eval set -- "${opts}"

  while [[ ${#} -gt 0 ]]; do
    case "${1}" in
    (-h|--help)
      print_help
      ;;
    (-b|--gpg-batch-file)
      GPG_BATCH_FILE="${2}"
      shift 2
      ;;
    (-d|--gpg-home-dir)
      GPG_HOME_DIR="${2}"
      shift 2
      ;;
    (-e|--email)
      EMAIL="${2}"
      shift 2
      ;;
    (-n|--name)
      NAME="${2}"
      shift 2
      ;;
    (-o|--output)
      OUTPUT_DIR="${2}"
      shift 2
      ;;
    (-p|--passphrase:)
      PASSPHRASE="${2}"
      shift 2
      ;;
    (-x|--expire-date)
      EXPIRE_DATE="${2}"
      shift 2
      ;;
    (--)
        shift; break
        ;;
    *)
      print_help
    esac
  done

  if [[ "${OUTPUT_DIR}" == "${HOME}"/.gnupg ]]; then
    echo "The output directory must not be ${HOME}/.gnupg!"
    exit 1
  fi
}

gen_batch_file() {
  local batch_comment="RPM ${1} GPG Keys"
  GPG_BATCH_FILE="${GPG_BATCH_FILE:-${TMP_DIR}/gpg.batch}"
  mkdir -p "${TMP_DIR}"

  if [[ ! -e "${GPG_BATCH_FILE}" ]]; then

cat <<- EOF > "${GPG_BATCH_FILE}"
%echo Generating RPM ${1} GPG Keys
Key-Type: RSA
Key-Length: 4096
Name-Real: ${NAME}
Name-Email: ${EMAIL}
Name-Comment: ${batch_comment}
Expire-Date: ${EXPIRE_DATE}
passphrase: ${PASSPHRASE}
%commit
%echo done
EOF
  fi
}

gen_keys() {
  gpg \
      --batch \
      --gen-key \
      --homedir "${GPG_HOME_DIR}" \
      "${GPG_BATCH_FILE}"

  rm -rf "${TMP_DIR}"
}

export_keys() {
    local export_comment="RPM ${1} GPG Keys"
    local output_dir="${OUTPUT_DIR}"/"${1}"

    gpg_base="gpg \
      --batch \
      --homedir=${GPG_HOME_DIR} \
      --pinentry-mode=loopback \
      --passphrase ${PASSPHRASE} \
      --armor"

    mkdir -p "${output_dir}"
    chmod 0700 "${output_dir}"

    sanity_check="$(gpg --homedir="${GPG_HOME_DIR}" \
      --list-secret-keys | grep "${export_comment}")"

    if [[ -z "${sanity_check}" ]]; then
      echo "Key with comment: ${export_comment} does not exist in ${GPG_HOME_DIR}!"
      exit 1
    fi

    ${gpg_base} \
      --output "${output_dir}"/key.pub \
      --export "${export_comment}"

    ${gpg_base} \
      --output "${output_dir}"/key.secret \
      --export-secret-key "${export_comment}"

    echo "${PASSPHRASE}" > "${output_dir}"/key.passphrase
}

make_rpm_repo_keys() {
  gen_batch_file "repo"
  gen_keys
  export_keys "repo"
}

make_rpm_package_keys() {
  gen_batch_file "packages"
  gen_keys
  export_keys "packages"
}

make_yocto_gpg_conf() {
  PDIR="$(dirname "${CWD}")"
  local gpg_base="${CWD}"
  local gpg_home_dir="${GPG_HOME_DIR}"

  if [[ -e "${PDIR}"/kas/simple-image.yaml ]]; then
      gpg_base="\${TOPDIR}/../${BASENAME}"
      gpg_home_dir="${gpg_base}"/output/gpg_home

  fi


cat <<- EOF > "${OUTPUT_DIR}"/gpg.conf
# Image changes necessary to enable rpm signing
# ============================

# Enable repository signing
INHERIT += "sign_package_feed"

# Enable rpm package signing
INHERIT += "sign_rpm"
PACKAGE_CLASSES = "package_rpm"

# RPM must be built with sequoia to enable rpm signing
PACKAGECONFIG:append:pn-rpm = " sequoia"
PACKAGECONFIG:append:pn-rpm-native = " sequoia"

# Path to GPG home directory.
GPG_PATH = "${gpg_home_dir}"

# RPM repository settings
# ============================

# Repo server URL. Set for runqemu.
# Run the repo with 'python3 -m http.server 8080'
PACKAGE_FEED_URIS = "http://192.168.7.1:8080"

# RPM repository Key name and password file
PACKAGE_FEED_GPG_NAME = "${NAME} (RPM repo GPG Keys)"
PACKAGE_FEED_GPG_PASSPHRASE_FILE = "${gpg_base}/output/repo/key.passphrase"

# ============================
# RPM package signing settings

RPM_GPG_NAME = "${NAME} (RPM packages GPG Keys)"
RPM_GPG_PASSPHRASE = "${PASSPHRASE}"
EOF

}

sanity_check() {
  local sanity_check="${GPG_HOME_DIR}"/gnupg_spawn_agent_sentinel.lock
  if [[ "${#sanity_check}" -ge 108 ]]; then
    echo "ERROR! The location of ${GPG_HOME_DIR} would exceed the max length of a unix socket (108)!"
    echo "This would result in package signing failures with the error: 'gpg: can't connect to the agent: File name too long!'"
    echo "Please choose a different output path with the -o argument!"
    exit 1
  fi
}

main() {
    parse_args "${@}"
    sanity_check
    mkdir -p "${GPG_HOME_DIR}"
    chmod 0700 "${GPG_HOME_DIR}"
    make_rpm_repo_keys
    make_rpm_package_keys
    make_yocto_gpg_conf
    echo "Keys are found in ${OUTPUT_DIR}"
}

main "${@}"
